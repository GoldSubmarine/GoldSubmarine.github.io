<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="author" content="GoldSubmarine"><title>RxJava Reactive Extension | Submarine</title><link rel="icon" href="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/toucan.png"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/goldsubmarine/goldsubmarine.github.io@master/css/style.css"><script src="https://gcore.jsdelivr.net/gh/goldsubmarine/goldsubmarine.github.io@master/js/script.js"></script><script src="https://gcore.jsdelivr.net/gh/goldsubmarine/goldsubmarine.github.io@master/js/tocbot.min.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="wrapper"><header><nav class="navbar"><div class="container"><div class="navbar-header header-logo"><a href="/">GoldSubmarine&#39;s Blog</a></div><div class="menu navbar-right"><div class="search-box"><div class="search-container"><span class="search-icon"><i class="fa fa-search"></i></span> <input type="input" id="search" autocomplete="off" placeholder="Search..."><div class="search-loader" style="display:none"></div></div><div id="search-result-container"></div></div><a class="menu-item" href="/archives">归档</a> <a class="menu-item" href="/category">分类</a> <a class="menu-item" href="/tag">标签</a> <a class="menu-item" href="/about">关于</a> <input id="switch_default" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div></nav><nav class="navbar-mobile" id="nav-mobile"><div class="container"><div class="navbar-header"><div><a href="/">GoldSubmarine&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a></div><div class="menu-toggle" onclick="mobileBtn()">&#9776; 菜单</div></div><div class="menu" id="mobile-menu"><a class="menu-item" href="/archives">归档</a> <a class="menu-item" href="/category">分类</a> <a class="menu-item" href="/tag">标签</a> <a class="menu-item" href="/about">关于</a></div></div></nav></header><script>var mobileBtn=function(){var e=document.getElementsByClassName("menu-toggle")[0],t=document.getElementById("mobile-menu");e.classList.contains("active")?(e.classList.remove("active"),t.classList.remove("active")):(e.classList.add("active"),t.classList.add("active"))}</script><script src="https://gcore.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script><meta property="algolia:search" data-application-id="OMMOIEMSAA" data-api-key="054cc564e105734852905d2e17a0640b" data-index-name="github_blog"><script>const algoliaConfig = document.querySelector('meta[property="algolia:search"]').dataset;
    const client = algoliasearch(algoliaConfig.applicationId, algoliaConfig.apiKey);
    const index = client.initIndex(algoliaConfig.indexName);
    let inputSearch = document.getElementById("search");
    let searchResultContainer = document.getElementById("search-result-container");
    let searchTimer;
    inputSearch.oninput = function(ev) {
        clearTimeout(searchTimer);
        searchTimer = setTimeout(function() {
            searchResultContainer.innerHTML = "";
            searchAlgolia();
        }, 300)
    }
    inputSearch.onblur = function() {
        setTimeout(function() {
            searchResultContainer.innerHTML = "";
        }, 500);
    }
    inputSearch.onfocus = function() {
        if(inputSearch.value) {
            searchAlgolia();
        }
    }
    function searchAlgolia() {
        if(!inputSearch.value || !inputSearch.value.trim()) {
            searchResultContainer.innerHTML = "";
            return;
        }
        document.getElementsByClassName('search-loader')[0].style = 'display: block'
        index.search(inputSearch.value.trim(), function(err, content) {
            if(content.hits.length) {
                console.log(content)
                let resultHtml = '<ul class="search-result">';
                let permalinkList = [];
                content.hits.forEach(hit => {
                    if(!permalinkList.includes(hit.permalink)) {
                        resultHtml += `<li><a href="${hit.permalink.replace(/http:\/\/yoursite\.com/, '')}">${hit.title}</a></li>`
                        permalinkList.push(hit.permalink)
                    }
                });
                resultHtml += '</ul>';
                searchResultContainer.innerHTML = resultHtml;
            } else {
                searchResultContainer.innerHTML = "";
            }
            document.getElementsByClassName('search-loader')[0].style = 'display: none'
        });
    }</script><div class="main"><div class="container"><div class="post-toc"><div class="tocbot-list"></div><div class="tocbot-list-menu"><a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a> <a onclick="go_top()">回到顶部</a> <a onclick="go_bottom()">前往底部</a></div></div><script>function expand_toc(){var o=document.querySelector(".tocbot-toc-expand");tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:6,orderedList:!1,scrollSmooth:!0}),o.setAttribute("onclick","collapse_toc()"),o.innerHTML="Collapse all"}function collapse_toc(){var o=document.querySelector(".tocbot-toc-expand");tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:1,orderedList:!1,scrollSmooth:!0}),o.setAttribute("onclick","expand_toc()"),o.innerHTML="Expand all"}function go_top(){window.scrollTo(0,0)}function go_bottom(){window.scrollTo(0,document.body.scrollHeight)}document.ready(function(){tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:1,orderedList:!1,scrollSmooth:!0})})</script><article class="post-wrap"><header class="post-header"><h1 class="post-title">RxJava Reactive Extension</h1><div class="post-meta">作者: <a itemprop="author" rel="author" href="/">GoldSubmarine</a> <span class="post-time">日期: <a href="#">2022-04-04&nbsp;&nbsp;23:11:00</a></span> <span class="post-category">分类: <a href="/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/">软件技术</a></span></div></header><div class="post-content"><h2 id="Observable-发布"><a href="#Observable-发布" class="headerlink" title="Observable 发布"></a>Observable 发布</h2><p><code>rx.Observable&lt;T&gt;</code>代表了一个流形式的值序列，如果想将<code>Observable&lt;T&gt;</code>与你更熟悉的事物进行类比，那么<code>Iterable&lt;T&gt;</code>可能是最接近的抽象形式。</p><p>Iterator 能够非常有效地生成无穷序列，例如，所有的自然数，如下所示</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220404232201.png" alt="20220404232201"></p><p>Observable 本质上是基于推送的，这意味着由它决定何时生成值。而 Iterator 则会一直处于空闲状态，直到有人调用 next()条目。Observable 能够产生任意数量的事件。显然，这与经典的观察者（observer）模式非常类似，该模式也被称为发布-订阅模式。</p><p><code>Observable&lt;T&gt;</code>可以生成三种类型的事件</p><ul><li>Observatble 声明的类型为 T 的值</li><li>完成事件</li><li>错误事件</li></ul><p>Reactive Extensions 规范明确规定，所有 Observable 都可以发布任意数量的值，并且可以跟随一个完成或错误事件（但是不能两者兼有）。严格来说，Rx 设计指南将该规则定义成了如下的形式：<code>OnNext*(OnCompleted | OnError)?</code></p><ul><li><code>OnNext OnCompleted</code> 发布一个值并结束</li><li><code>OnNext+ OnCompleted</code> 发布多个值并结束</li><li><code>OnNext+</code> 发布无限个值，没有结束</li><li><code>只有OnCompleted或OnError</code> 表示正常或非正常的终止</li><li><code>OnNext+ OnError</code> 发布多个值后发生了错误</li><li>除此之外，你还可以实现不发布任何事件的 Observable，包括完成或错误事件。</li></ul><h2 id="订阅-Observable"><a href="#订阅-Observable" class="headerlink" title="订阅 Observable"></a>订阅 Observable</h2><p>前面讲到 Observable 是延迟执行的，只有被 subscribe 后才会执行</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220404234944.png" alt="20220404234944"></p><p>RxJava 契约会确保你的回调不会同时在多个线程中触发，即便事件是从多个线程中发布的。Observable 一般不会抛出异常，异常是 Observable 能够传播的另一种通知（事件）类型。所以，你不能围绕着 subscribe()使用 try-catch 代码块来捕获这个过程中的异常，而是提供一个单独的回调，如下所示。</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220404235202.png" alt="20220404235202"></p><p>subscribe()有多个重载版本，第二个参数是可选的。它会通知在生成条目的时候可能会抛出的异常，保证在这个异常之后，不会有其他的 Tweet 出现。在 Observable 中，异常是一等公民。抛出的异常可以快速传播，产生很多的副作用，比如不一致的数据结构或失败的事务。</p><p>第三个可选的回调让我们能够监听流的结束</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220404235854.png" alt="20220404235854"></p><p>如果你一开始就知道某个流是无穷的，那么订阅完成通知就没有意义了。另一方面，在某些场景中，流结束可能恰好是实际要等待的事件。</p><p>可以将 subscribe 的三个回调函数封装到一个<code>Observer&lt;T&gt;</code>类中。如下所示</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220405000305.png" alt="20220405000305"></p><h2 id="使用-Subscription-和-Subscriber-lt-T-gt-控制监听器"><a href="#使用-Subscription-和-Subscriber-lt-T-gt-控制监听器" class="headerlink" title="使用 Subscription 和 Subscriber&lt;T&gt; 控制监听器"></a>使用 Subscription 和 <code>Subscriber&lt;T&gt;</code> 控制监听器</h2><p>一个 Observable 可以有多个订阅者。类似于发布者-订阅者模式，一个发布者可以分发事件给多个消费者。<code>Observable&lt;T&gt;</code>只是一个类型化数据结构，它可能存活很短的时间，也可能只要服务器程序在运行，它就持续存活。</p><p>Observer 有订阅的能力，那么它也应该具有在合适的情况下取消订阅的能力。有两种方式支持该功能：Subscription 和 Subscriber。</p><p>Subscription 的使用方式如下</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220405001002.png" alt="20220405001002"></p><p>除了使用 Subscription 取消订阅，还可以在监听者内部实现取消订阅，即<code>Subscriber&lt;T&gt;</code>，它同时实现了<code>Observer&lt;T&gt;</code>和 Subscription。</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220405001637.png" alt="20220405001637"></p><h2 id="创建-Observable"><a href="#创建-Observable" class="headerlink" title="创建 Observable"></a>创建 Observable</h2><p>为了保证你真正理解订阅是如何运行的，不妨考虑如下的样例，它对同一个 Observable 订阅了两次。</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220405175022.png" alt="20220405175022"><br><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220405175041.png" alt="20220405175041"></p><p>每次调用 subscribe 时，都会调用 create 方法里的回调函数，并且整个过程都在 main 线程中运行，没有创建新的线程。</p><p>如果你不想为所有订阅者调用 create()，而是想重用已经计算的事件，那么可以使用非常便利的 cache()操作符。</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220405175458.png" alt="20220405175458"></p><p>cache()和无穷流组合将会带来灾难性的结果，也就是 OutOfMemoryError。</p><p>因为 create 中的 lambda 函数是在 main 线程中执行的，想象我们要创建一个生成所有自然数的无穷流，那 lambda 函数永远不会结束，subscribe 函数也会永远被阻塞住。你可能会问：订阅函数的执行不应该是异步的嘛，怎么会在 main 线程中执行呢？下面让我们显示的并发一下</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220405182122.png" alt="20220405182122"></p><p>这里不再是在客户端线程中直接运行阻塞循环，而是生成了一个自定义的线程，在该线程中发布事件。现在，subscribe()不会再阻塞客户端线程，因为它底层做的事情仅仅是生成一个线程。此处只是一个并发展示，RxJava 也有更好的声明式工具来处理并发。</p><p>Rx 要求订阅者不能并发地接收通知。涉及显式的线程时，很容易违反这个要求。按照这样的假设，可以编写同步的 Observer，通常只能由一个线程进行访问。</p><p>建议尽可能频繁地检查 isUnsubscribed()标记，从而避免将事件发送给那些已经不再想接收新事件的订阅者。更好的处理方式是取消订阅后，立刻清理资源，而不是等待 10 秒后，才发现已经取消了订阅。subscriber 实例提供了 add 方法用于注册取消订阅的回调</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220405184423.png" alt="20220405184423"></p><p>错误处理通常使用 try-catch 代码块，如下图：</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220406002227.png" alt="20220406002227"></p><p>Observable 通过一个值来结束，并且使用 try-catch 来进行包装是非常常见的模式，所以 RxJava 引入了内置的 fromCallable()操作符。在语义上，它与前面的代码相同，但是更加简短。</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220406002314.png" alt="20220406002314"></p><p>计时：timer()和 interval()，效果和 js 中的 setTimeout/setInterval 相同，它们在底层会创建一个线程，异步的执行回调函数</p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220406003123.png" alt="20220406003123"></p><p><img src="https://gcore.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220406003215.png" alt="20220406003215"></p><h2 id="hot-和-cold-类型的-Observable"><a href="#hot-和-cold-类型的-Observable" class="headerlink" title="hot 和 cold 类型的 Observable"></a>hot 和 cold 类型的 Observable</h2><p>cold 类型的 Observable 完全是延迟（lazy）执行的，如果没有观察者，那么 Observable 只是一个静态的数据结构，不会执行。cold 类型的 Observable 通常来源于 Observable.create()，还包括 Observable.just()、from()和 range()。从某种程度上来说，cold 类型的 Observable 依赖 Subscriber，每个订阅者会得到独立的流。</p><p>hot 类型的 Observable 不管是否有 Subscriber，它都可能已经开始发布事件了。通常发生在完全无法控制事件源的场景下。包括鼠标移动、键盘输入或按钮点击。</p><p>cold 类型的 Observable，你都会获得完整且一致的事件集。但如果 Observable 是 hot 类型的，那么你就无法确保能接收到所有事件。在技术上来讲，可以缓冲（cache 操作符）来自 hot 类型 Observable 的所有事件，让后续的订阅者都能接收到相同的事件序列，但是它消耗的内存量是没有限制的，所以在缓存 hot 类型的 Observable 时要非常小心。</p></div><section class="post-copyright"><p class="copyright-item"><span>作者:</span> <span>GoldSubmarine</span></p><p class="copyright-item"><span>原文地址:</span> <span><a href="https://goldsubmarine.github.io/2022/04/04/rxjava-reactive-extension/">https://goldsubmarine.github.io/2022/04/04/rxjava-reactive-extension/</a></span></p><p class="copyright-item"><span>许可:</span> <span>Copyright (c) 2022 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span></p></section><section class="post-tags"><div><span>Tag(s):</span> <span class="tag"><a href="/tags/RxJava/"># RxJava</a></span></div><div><a href="javascript:window.history.back();">back</a> <span>·</span> <a href="/">home</a></div></section><section class="post-nav"><a class="prev" rel="prev" href="/2022/05/04/%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/">代理配置</a> <a class="next" rel="next" href="/2022/04/04/rxjava-%E7%AE%80%E4%BB%8B/">RxJava 简介</a></section></article></div><div id="gitalk-container"></div><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/gitalk@1.5.2/dist/gitalk.css"><script src="https://gcore.jsdelivr.net/npm/gitalk@1.5.2/dist/gitalk.min.js"></script><script src="https://gcore.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script src="https://gcore.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
        clientID: '4eeae5fd36daf5647141',
        clientSecret: 'be865c2d10e4a71994120646ff80bdaef656b9be',
        repo: 'GoldSubmarine.github.io',
        owner: 'GoldSubmarine',
        admin: 'GoldSubmarine',
        id: md5(location.pathname),
        labels: 'Gitalk'.split(',').filter(l => l),
        perPage: 10,
        pagerDirection: 'last',
        createIssueManually: true,
        distractionFreeMode: false
      })
      gitalk.render('gitalk-container')

      mediumZoom(document.querySelectorAll("img"), { background: '#212530' })</script><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://gcore.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://gcore.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script></div><footer id="footer" class="footer"><div class="copyright"><span>© GoldSubmarine | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span></div></footer></div></body></html>