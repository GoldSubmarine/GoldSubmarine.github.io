<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="author" content="GoldSubmarine"><title>Haskell 初探 | Submarine</title><link rel="icon" href="https://cdn.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/toucan.png"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/goldsubmarine/goldsubmarine.github.io@master/css/style.css"><script src="https://cdn.jsdelivr.net/gh/goldsubmarine/goldsubmarine.github.io@master/js/script.js"></script><script src="https://cdn.jsdelivr.net/gh/goldsubmarine/goldsubmarine.github.io@master/js/tocbot.min.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="wrapper"><header><nav class="navbar"><div class="container"><div class="navbar-header header-logo"><a href="/">GoldSubmarine&#39;s Blog</a></div><div class="menu navbar-right"><div class="search-box"><div class="search-container"><span class="search-icon"><i class="fa fa-search"></i></span> <input type="input" id="search" autocomplete="off" placeholder="Search..."><div class="search-loader" style="display:none"></div></div><div id="search-result-container"></div></div><a class="menu-item" href="/archives">归档</a> <a class="menu-item" href="/category">分类</a> <a class="menu-item" href="/tag">标签</a> <a class="menu-item" href="/about">关于</a> <input id="switch_default" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div></nav><nav class="navbar-mobile" id="nav-mobile"><div class="container"><div class="navbar-header"><div><a href="/">GoldSubmarine&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a></div><div class="menu-toggle" onclick="mobileBtn()">&#9776; 菜单</div></div><div class="menu" id="mobile-menu"><a class="menu-item" href="/archives">归档</a> <a class="menu-item" href="/category">分类</a> <a class="menu-item" href="/tag">标签</a> <a class="menu-item" href="/about">关于</a></div></div></nav></header><script>var mobileBtn=function(){var e=document.getElementsByClassName("menu-toggle")[0],t=document.getElementById("mobile-menu");e.classList.contains("active")?(e.classList.remove("active"),t.classList.remove("active")):(e.classList.add("active"),t.classList.add("active"))}</script><script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script><meta property="algolia:search" data-application-id="OMMOIEMSAA" data-api-key="054cc564e105734852905d2e17a0640b" data-index-name="github_blog"><script>const algoliaConfig = document.querySelector('meta[property="algolia:search"]').dataset;
    const client = algoliasearch(algoliaConfig.applicationId, algoliaConfig.apiKey);
    const index = client.initIndex(algoliaConfig.indexName);
    let inputSearch = document.getElementById("search");
    let searchResultContainer = document.getElementById("search-result-container");
    let searchTimer;
    inputSearch.oninput = function(ev) {
        clearTimeout(searchTimer);
        searchTimer = setTimeout(function() {
            searchResultContainer.innerHTML = "";
            searchAlgolia();
        }, 300)
    }
    inputSearch.onblur = function() {
        setTimeout(function() {
            searchResultContainer.innerHTML = "";
        }, 500);
    }
    inputSearch.onfocus = function() {
        if(inputSearch.value) {
            searchAlgolia();
        }
    }
    function searchAlgolia() {
        if(!inputSearch.value || !inputSearch.value.trim()) {
            searchResultContainer.innerHTML = "";
            return;
        }
        document.getElementsByClassName('search-loader')[0].style = 'display: block'
        index.search(inputSearch.value.trim(), function(err, content) {
            if(content.hits.length) {
                console.log(content)
                let resultHtml = '<ul class="search-result">';
                let permalinkList = [];
                content.hits.forEach(hit => {
                    if(!permalinkList.includes(hit.permalink)) {
                        resultHtml += `<li><a href="${hit.permalink.replace(/http:\/\/yoursite\.com/, '')}">${hit.title}</a></li>`
                        permalinkList.push(hit.permalink)
                    }
                });
                resultHtml += '</ul>';
                searchResultContainer.innerHTML = resultHtml;
            } else {
                searchResultContainer.innerHTML = "";
            }
            document.getElementsByClassName('search-loader')[0].style = 'display: none'
        });
    }</script><div class="main"><div class="container"><div class="post-toc"><div class="tocbot-list"></div><div class="tocbot-list-menu"><a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a> <a onclick="go_top()">回到顶部</a> <a onclick="go_bottom()">前往底部</a></div></div><script>function expand_toc(){var o=document.querySelector(".tocbot-toc-expand");tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:6,orderedList:!1,scrollSmooth:!0}),o.setAttribute("onclick","collapse_toc()"),o.innerHTML="Collapse all"}function collapse_toc(){var o=document.querySelector(".tocbot-toc-expand");tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:1,orderedList:!1,scrollSmooth:!0}),o.setAttribute("onclick","expand_toc()"),o.innerHTML="Expand all"}function go_top(){window.scrollTo(0,0)}function go_bottom(){window.scrollTo(0,document.body.scrollHeight)}document.ready(function(){tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:1,orderedList:!1,scrollSmooth:!0})})</script><article class="post-wrap"><header class="post-header"><h1 class="post-title">Haskell 初探</h1><div class="post-meta">作者: <a itemprop="author" rel="author" href="/">GoldSubmarine</a> <span class="post-time">日期: <a href="#">2020-03-09&nbsp;&nbsp;03:18:00</a></span> <span class="post-category">分类: <a href="/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/">软件技术</a></span></div></header><div class="post-content"><p>只讲特性，不讲语法</p><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">take</span> <span class="number">4</span> [<span class="number">13</span>,<span class="number">26.</span>.]</span><br><span class="line"><span class="comment">-- [13, 26, 39, 52]</span></span><br></pre></td></tr></table></figure><p>从步长为 13 的无限数组中取出前 4 位，可以出现无限数组，因为定义的时候并没有计算，而是调用的时候，前面写了 4 ，于是计算到第 44 个数时，就停止计算了</p><p>java 的 Stream 中的所有环节都是惰性的，本质只循环了一次</p><h2 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h2><p>Haskell 中的 <code>List Comprehension</code></p><p>如何取得所有三边长度皆为整数且小于等于 10，周长为 24 的直角三角形？</p><p>首先，把所有三遍长度小于等于 10 的三角形都列出来：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> triangles = [ (a,b,c) | c &lt;- [<span class="number">1.</span><span class="number">.10</span>], b &lt;- [<span class="number">1.</span><span class="number">.10</span>], a &lt;- [<span class="number">1.</span><span class="number">.10</span>] ]</span><br></pre></td></tr></table></figure><p>上述代码从三个 List 中取值，并组合为一个三元组。接下来开始过滤这些三元组，增加限制条件：直角三角形，同时也考虑上 b 边要短于斜边，a 边要短于 b 边情况</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> rightTriangles = [ (a,b,c) | c &lt;- [<span class="number">1.</span><span class="number">.10</span>], b &lt;- [<span class="number">1.</span>.c], a &lt;- [<span class="number">1.</span>.b], a^<span class="number">2</span> + b^<span class="number">2</span> == c^<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>最后告诉它只要周长为 24 的三角形</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> rightTriangles = [ (a,b,c) | c &lt;- [<span class="number">1.</span><span class="number">.10</span>], b &lt;- [<span class="number">1.</span>.c], a &lt;- [<span class="number">1.</span>.b], a^<span class="number">2</span> + b^<span class="number">2</span> == c^<span class="number">2</span>, a+b+c == <span class="number">24</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; rightTriangles</span><br><span class="line">[(<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>在命令式语言中，有控制流程，随着命令的执行，状态就会随之发生改变。</p><p>然而在函数式编程语言中，你不是像命令式语言那样命令电脑“要做什么”，而是通过用函数来描述出问题“是什么”</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组的使用表示二维向量，[[1,2],[8,1,15],[4,5]]，尽管数组可可以表示，但是可能会产生三个数据，而元组能固定一个数据结构。</p><p>java 中有封装好的 Pair 和 Tuple，但是不能只是把它当作一个封装类去使用它，而要把它看作一种基本概念，就像枚举一样。</p><h2 id="一切皆函数"><a href="#一切皆函数" class="headerlink" title="一切皆函数"></a>一切皆函数</h2><p>Haskell 有一个中辍函数的概念</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 判断4是否在集合中</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> `elem` [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure><p><code>elem</code> 就是一个中辍函数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; :t (+)</span><br><span class="line">(+) :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure><p>加法本质上也是一个函数，通过 <code>:t</code> 可以查看它的类型约束，可以看到本质就是一个加法函数</p><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sayMe</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">1</span> = <span class="string">"One!"</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">2</span> = <span class="string">"Two!"</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">3</span> = <span class="string">"Three!"</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">4</span> = <span class="string">"Four!"</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">5</span> = <span class="string">"Five!"</span></span><br><span class="line"><span class="title">sayMe</span> x = <span class="string">"Not between 1 and 5"</span></span><br></pre></td></tr></table></figure><p>sayMe 是一个函数，当调用 <code>sayMe 2</code> 时返回 “Two!”，当调用 <code>sayMe 12</code> 时返回 “Not between 1 and 5”，要是没有模式匹配的话，那可得好大一棵 if-else 树了！</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">factorial</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; a</span><br><span class="line"><span class="title">factorial</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">factorial</span> n = n * factorial (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>从上述代码可以看到，可以将模式匹配和递归配合起来，实现阶乘阶</p><h2 id="门卫"><a href="#门卫" class="headerlink" title="门卫"></a>门卫</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">bmiTell</span> weight height</span><br><span class="line">    | bmi &lt;= skinny = <span class="string">"You're underweight, you emo, you!"</span></span><br><span class="line">    | bmi &lt;= normal = <span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span></span><br><span class="line">    | bmi &lt;= fat    = <span class="string">"You're fat! Lose some weight, fatty!"</span></span><br><span class="line">    | otherwise     = <span class="string">"You're a whale, congratulations!"</span></span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span></span><br><span class="line">          skinny = <span class="number">18.5</span></span><br><span class="line">          normal = <span class="number">25.0</span></span><br><span class="line">          fat = <span class="number">30.0</span></span><br></pre></td></tr></table></figure><p>通过 <code>|</code> 表示 if else，where 中定义的变量对所有门卫都可见，也可以在每个门卫内用 let 定义变量，只对门卫可见。</p><h2 id="柯里函数"><a href="#柯里函数" class="headerlink" title="柯里函数"></a>柯里函数</h2><p>Haskell 中所有的函数都是柯里函数，只有一个参数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; max <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; (max <span class="number">4</span>) <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> cacheMax = max <span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; cacheMax <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>max 函数的类型为 <code>max :: (Ord a) =&gt; a -&gt; a -&gt; a</code> ，也可以写作 <code>max :: (Ord a) =&gt; a -&gt; (a -&gt; a)</code>，而不是 <code>max :: (a, a) =&gt; a</code></p><p>柯里化和协程的区别：协程调用时需要一次性提供全部的入参，执行时可停顿，而柯里化不仅能实现执行的暂停，更重要的是函数可以方便的组合。</p><p>下面是一些示例：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">divideByTen</span> :: (<span class="type">Floating</span> a) =&gt; a -&gt; a</span><br><span class="line"><span class="title">divideByTen</span> = (/<span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 首字母是否大写</span></span><br><span class="line"><span class="title">isUpperAlphanum</span> :: <span class="type">Char</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isUpperAlphanum</span> = (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>])</span><br></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>封装一个 zipWith 功能</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zipWith'</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span><br><span class="line"><span class="title">zipWith'</span> _ [] _ = []</span><br><span class="line"><span class="title">zipWith'</span> _ _ [] = []</span><br><span class="line"><span class="title">zipWith'</span> f (x:xs) (y:ys) = f x y : zipWith' f xs ys</span><br><span class="line"><span class="comment">-- f为传入的函数，第二个和三个参数为list，x和y分别表示两个list的第一个元素</span></span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zipWith' (+) [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] [<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; zipWith' max [<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; zipWith' (++) [<span class="string">"foo "</span>，<span class="string">"bar "</span>，<span class="string">"baz "</span>] [<span class="string">"fighters"</span>，<span class="string">"hoppers"</span>，<span class="string">"aldrin"</span>]</span><br><span class="line">[<span class="string">"foo fighters"</span>,<span class="string">"bar hoppers"</span>,<span class="string">"baz aldrin"</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; zipWith' (*) (replicate <span class="number">5</span> <span class="number">2</span>) [<span class="number">1.</span>.]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; zipWith' (zipWith' (*)) [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]] [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]]</span><br><span class="line">[[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">9</span>,<span class="number">20</span>,<span class="number">30</span>],[<span class="number">10</span>,<span class="number">12</span>,<span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>一些其他的常用函数</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">map</span> _ [] = []</span><br><span class="line"><span class="title">map</span> f (x:xs) = f x : map f xs</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (+<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; map (++ <span class="string">"!"</span>) [<span class="string">"BIFF"</span>，<span class="string">"BANG"</span>，<span class="string">"POW"</span>]</span><br><span class="line">[<span class="string">"BIFF!"</span>,<span class="string">"BANG!"</span>,<span class="string">"POW!"</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; map (replicate <span class="number">3</span>) [<span class="number">3.</span><span class="number">.6</span>]</span><br><span class="line">[[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="title">ghci</span>&gt; map (map (^<span class="number">2</span>)) [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">36</span>],[<span class="number">49</span>,<span class="number">64</span>]]</span><br><span class="line"><span class="title">ghci</span>&gt; map fst [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>你可能会发现，以上的所有代码都可以用 List Comprehension 来替代。<code>map (+3) [1,5,3,1,6]</code> 与 <code>[x+3 | x &lt;- [1,5,3,1,6]</code> 完全等价。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filter</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">filter</span> _ [] = []</span><br><span class="line"><span class="title">filter</span> p (x:xs)</span><br><span class="line">    | p x       = x : filter p xs</span><br><span class="line">    | otherwise = filter p xs</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; filter (&gt;<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; filter (==<span class="number">3</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; filter even [<span class="number">1.</span><span class="number">.10</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> notNull x = not (null x) <span class="keyword">in</span> filter notNull [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>],[],[],[]]</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="title">ghci</span>&gt; filter (`elem` ['a'..'z']) <span class="string">"u LaUgH aT mE BeCaUsE I aM diFfeRent"</span></span><br><span class="line"><span class="string">"uagameasadifeent"</span></span><br><span class="line"><span class="title">ghci</span>&gt; filter (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>]) <span class="string">"i lauGh At You BecAuse u r aLL the Same"</span></span><br><span class="line"><span class="string">"GAYBALLS"</span></span><br></pre></td></tr></table></figure><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>lambda 就是匿名函数。有些时候我们需要传给高阶函数一个函数，而这函数我们只会用这一次，这就弄个特定功能的 lambda。编写 lambda，就写个 \</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zipWith (\a b -&gt; (a * <span class="number">30</span> + <span class="number">3</span>) / b) [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">153.0</span>,<span class="number">61.5</span>,<span class="number">31.0</span>,<span class="number">15.75</span>,<span class="number">6.6</span>]</span><br></pre></td></tr></table></figure><p>由于有柯里化，如下的两段是等价的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addThree</span> :: (<span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">addThree</span> x y z = x + y + z</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addThree</span> :: (<span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">addThree</span> = \x -&gt; \y -&gt; \z -&gt; x + y + z</span><br><span class="line"><span class="comment">-- 等于号可以看作返回值,类似js中的=&gt;,或java中的-&gt;</span></span><br></pre></td></tr></table></figure><p>当然第一段代码更易读，不过第二个函数使得柯里化更容易理解。</p><h2 id="有-的函数调用"><a href="#有-的函数调用" class="headerlink" title="有 $ 的函数调用"></a>有 $ 的函数调用</h2><p>普通的函数调用符有最高的优先级，而$的优先级则最低。它可以减少我们代码中括号的数目。</p><p><code>sqrt 3 + 4 + 9</code> 相当于 <code>(sqrt 3) + 4 + 9</code>,但是如果想要获取 <code>(3 + 4 + 9)</code> 的平方根,可以写成 <code>sqrt $ 3 + 4 + 9</code> 相当于 <code>sqrt (3 + 4 + 9)</code></p><p>除了减少括号外，$还可以将数据作为函数使用。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map ($ <span class="number">3</span>) [(<span class="number">4</span>+),(<span class="number">10</span>*),(^<span class="number">2</span>),sqrt]</span><br><span class="line">[<span class="number">7.0</span>,<span class="number">30.0</span>,<span class="number">9.0</span>,<span class="number">1.7320508075688772</span>]</span><br></pre></td></tr></table></figure><h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><p>在数学中，函数组合是这样定义的：<code>(f*g)(x) = f(g(x))</code></p><p>haskell 中的函数组合与之很像，即 <code>.</code> 函数。其定义为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</span><br><span class="line"><span class="title">f</span> . g = \x -&gt; f (g x)</span><br></pre></td></tr></table></figure><p>假设我们有一组由数字组成的 list，要将其全部转为负数再求和，很容易就想到应先取其绝对值，再取负数再求和，像这样：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (\x -&gt; sum (negate (abs x))) [<span class="number">5</span>,<span class="number">-3</span>,<span class="number">-6</span>,<span class="number">7</span>,<span class="number">-3</span>,<span class="number">2</span>,<span class="number">-19</span>,<span class="number">24</span>]</span><br><span class="line">[<span class="number">-5</span>,<span class="number">-3</span>,<span class="number">-6</span>,<span class="number">-7</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-19</span>,<span class="number">-24</span>]</span><br></pre></td></tr></table></figure><p><code>.</code> 函数写法为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (sum . negate . abs) [<span class="number">5</span>,<span class="number">-3</span>,<span class="number">-6</span>,<span class="number">7</span>,<span class="number">-3</span>,<span class="number">2</span>,<span class="number">-19</span>,<span class="number">24</span>]</span><br><span class="line">[<span class="number">-5</span>,<span class="number">-3</span>,<span class="number">-6</span>,<span class="number">-7</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-19</span>,<span class="number">-24</span>]</span><br></pre></td></tr></table></figure><p>不过含多个参数的函数该怎么办?我们可以使用不全调用使每个函数都只剩下一个参数</p><p><code>sum (replicate 5 (max 6.7 8.9))</code> 可以重写为 <code>(sum . replicate 5 . max 6.7) 8.9</code> 或 <code>sum . replicate 5 . max 6.7 $ 8.9</code></p><h3 id="point-free-style"><a href="#point-free-style" class="headerlink" title="point free style"></a>point free style</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">max11'</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">max11'</span> a = max <span class="number">11</span> a</span><br></pre></td></tr></table></figure><p>因为柯里化的存在，所以可以改写为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">max11'</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">max11'</span> = max <span class="number">11</span></span><br></pre></td></tr></table></figure><p>同样，<code>fn x = sum (replicate 5 (max 11 x))</code> 可以改写为 <code>fn = sum . replicate 5 . max 11</code></p><p>point free style会令你去思考函数的组合方式，而非数据的传递方式，更加简洁直白。不过函数若过于复杂，再使用point free style往往会适得其反，因此构造较长的函数组合链是不被鼓励的</p></div><section class="post-copyright"><p class="copyright-item"><span>作者:</span> <span>GoldSubmarine</span></p><p class="copyright-item"><span>原文地址:</span> <span><a href="https://goldsubmarine.github.io/2020/03/09/haskell-%E5%88%9D%E6%8E%A2/">https://goldsubmarine.github.io/2020/03/09/haskell-%E5%88%9D%E6%8E%A2/</a></span></p><p class="copyright-item"><span>许可:</span> <span>Copyright (c) 2022 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span></p></section><section class="post-tags"><div><span>Tag(s):</span> <span class="tag"><a href="/tags/Haskell/"># Haskell</a></span></div><div><a href="javascript:window.history.back();">back</a> <span>·</span> <a href="/">home</a></div></section><section class="post-nav"><a class="prev" rel="prev" href="/2020/03/14/mysql-%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/">Mysql 入门到精通</a> <a class="next" rel="next" href="/2020/02/24/%E7%A4%BE%E4%BC%9A%E5%A5%91%E7%BA%A6%E8%AE%BA/">社会契约论</a></section></article></div><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.2/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
        clientID: '4eeae5fd36daf5647141',
        clientSecret: 'be865c2d10e4a71994120646ff80bdaef656b9be',
        repo: 'GoldSubmarine.github.io',
        owner: 'GoldSubmarine',
        admin: 'GoldSubmarine',
        id: md5(location.pathname),
        labels: 'Gitalk'.split(',').filter(l => l),
        perPage: 10,
        pagerDirection: 'last',
        createIssueManually: true,
        distractionFreeMode: false
      })
      gitalk.render('gitalk-container')

      mediumZoom(document.querySelectorAll("img"), { background: '#212530' })</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script></div><footer id="footer" class="footer"><div class="copyright"><span>© GoldSubmarine | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span></div></footer></div></body></html>