---
title: DDD入门
date: 2022-01-22 22:32:00
tags: 领域驱动设计
categories: 软件技术
---

在实施 DDD 的过程中，你最好将那些不怎么使用技术语言的领域专家加进自己的团队。就像你会向他们学习一样，他们也会向你学习。

领域专家并不是一个职位，他可以是精通业务的任何人。他们可能了解更多的关于业务领域的背景知识，他们可能是软件产品的设计者，甚至有可能是销售员。

## 什么是领域模型？

领域模型是关于某个特定业务领域的软件模型。通常，领域模型通过**对象模型**来实现，这些对象同时包含了**数据**和**行为**，并且表达了准确的业务含义。

## 领域驱动的好处

1. DDD 将领域专家和开发人员聚集到一起，这样所开发的软件能够反映出领域专家的思维模型
   1. 这并不意味这我们将精力都花在了对“真实世界”的建模上，而是交付最具业务价值的软件。有时在**实用和理想之间存在冲突**，根据它们的互异程度，在 DDD 中我们将选择实用性。
   2. 领域专家将和开发人员一起创建一套适用于领域建模的通用语言。通用语言必须在全队范围之内达成一致；所有成员都使用通用语言进行交流，通用语言也是对软件模型的直接反映。
   3. 通用语言也有助于促使原本存在分歧的领域专家们达成一致意见。此外，通过将领域知识传达给所有的团队成员，包括开发人员，整个团队也将更具凝聚力。我们甚至可以认为，这是每个公司都应该有的对于知识型工作者的起码训练。
2. DDD 关注业务战略。
   1. 它帮助我们定义不同团队之间的组织关系，并在这些关系有可能导致项目失败的时候提供早期预警。
   2. DDD 的战略设计用于清楚地界分不同的系统和业务关注点，这样可以保护每个业务层面的服务。更进一步，这将指引我们如何实现面向服务架构或者业务驱动架构。
3. 通过使用战术设计建模工具，DDD 满足了软件真正的技术需求。
   1. 这些战术设计工具使开发人员能够按照领域专家的思维模型开发软件。
   2. 同时，所开发出来的软件是可测试的，能够尽量避免错误，能执行服务层面协议（Service-LevelAgreement，SLA），具有很好的伸缩性，并且允许分布式计算。
   3. DDD 的最佳实践同时包含了高层的架构性实践和底层设计实践，关注业务规则和数据不变性，并且可以对业务规则起到保护作用。

## 处理领域复杂性

在使用 DDD 时，我们首先希望将它应用在最重要的业务场景下。对于那些可以轻易替换的软件来说，你是不会有所投入的。相反，值得你投入的是那些重要的、复杂的东西，因为这些东西将为你带来可观的回报。正因如此，我们将这样的模型命名为核心域（Core Domain，2），而那些相对次要的称为支撑子域（Supporting Subdomain，2）。

DDD 的作用是简化，而不是复杂化

不同的业务领域对于复杂的定义是不一样的。另外，不同的公司所面临的挑战不一样；成熟度不一样；软件开发能力也不一样。因此，与其去定义什么是复杂的，还不如定义什么是**重要**的。这时，你的团队和管理层应该做出决定：你们开发的软件系统是否值得做出 DDD 投入。

## DDD 计分卡

![20220126003208](https://cdn.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220126003208.png)

一旦我们做出了重要的架构决策，并且已经在该架构下进行了深入地开发，通常我们也被绑定在这个架构下了，所以在决定时一定要慎重。

## 贫血模型

你所说的领域对象根本就不是领域对象，而只是将关系型数据库中的模型映射到了对象上而已。这样的领域对象更像是活动记录（Active Record），此时你可以对架构做个简化，然后使用事务脚本（Transaction Script）进行开发。

如果说贫血领域对象是由设计不当造成的，为什么还有如此多的人认为他们的领域对象是健康的呢？其中一个原因是：**贫血领域对象反映了一种自然的过程式的编程风格**，但我并不认为这是首要原因。软件业中有很多开发者都是学着示例代码做开发的，这并不是什么坏事，只要示例代码本身是好的。然而，通常情况是，**示例代码只是用尽可能简单的方式来展示某个特定的概念或者 API 特性，而并不强调要遵循多好的设计原则。**

## 示例

阅读一个贫血领域对象的示例代码，比如应用服务中的事务脚本

![20220126004244](https://cdn.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220126004244.png)

以上代码完成了什么功能呢？事实上，以上代码的功能是相当强大的。不管一个 Customer 是新建的还是先前存在的；不管是 Customer 的名字变了还是他搬进了新家；不管是他的家用电话号码变了还是他有了新的移动电话；也不管他是改用 Gmail 还是有了新的 E-mail 地址，这段代码都会保存这个 Customer。

情况真是这样的吗？其实，**我们并不知道 saveCustomer() 方法的业务场景**。你不相信？那请看看该方法的下一个版本：

![20220126004611](https://cdn.jsdelivr.net/gh/goldsubmarine/cdn@master/blog/20220126004611.png)

我们能说这是好的代码吗？我们如何测试这段代码以保证在错误的业务场景下该段代码不应该保存一个 Customer 呢？都不用讨论过多的细节我们便知道，在很多情况下该方法是不能正常工作的。

你可能会查看很多客户代码，然后比较代码历史，找出 saveCustomer（）的来龙去脉。你会发现，没有人能够解释这个方法为什么会成为现在这个样子，也没有人知道究竟有多少客户代码在正确地使用 saveCustomer（）方法。

上面的 saveCustomer（）至少存在三大问题：

1. saveCustomer（）业务意图不明确。
2. 方法的实现本身增加了潜在的复杂性。
3. Customer 领域对象根本就不是对象，而只一个数据持有器（data holder）。

我们将这种情况称为**由贫血症导致的失忆症**，在实际项目中，这种症状发生得太多了。
