---
title: JVM 笔记
date: 2019-11-26 22:40:45
tags: java
---

## Java 内存区域

### 程序计数器

每个线程私有的一块较小的内存空间。通过改变计数器的值来选取下一个需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复都依赖于它。

### 虚拟机栈

线程私有的一块内存，用于描述方法执行的内存模型：每个方法在执行的而同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。当线程请求的栈深度大于虚拟机允许的深度时，抛出 StackOverflowError

### 堆

Java 虚拟机所管理的内存中最大的一块区域。所有线程共享 这块堆内存。所有的实例对象都存放在此

### 方法区

线程共享的一块区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Hotspot 使用永久代来实现方法区，但其他虚拟机并未这么做，所以他们不等价

### 运行时常量池

它是方法区的一部分。Class 文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息时常量池。运行期间也可将新的常量放入池中，例如 String 类的 intern()方法

## HotSpot 虚拟机对象探秘

### 对象创建

虚拟机遇到一条 new 指令时，首先检查能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有则先执行类加载。

类加载通过后，对象所需内存的大小在类加载完成后便可确定，虚拟机将为新生对象分配内存。java 堆中的内存可以是绝对规整的，也可以是零散的，取决于 GC 是否带有压缩整理的功能，不通的虚拟机表现不通。如果是规整的，只需分配内存的指针移动一段与对象大小相等的内存即可，这种方法叫“指针碰撞”（因多线程，所以采用 CAS 移动指针，保证原子性）。如果是零散的，那么虚拟机维护了一个表用于记录哪些内存块是可用的，这种分配方式被称为“空闲列表”。

对象创建后，虚拟机要对对象进行必要的设置，例如这个对象属于哪个类的实例、如何找到类的元数据信息、哈希码、GC 分代年龄等，这些信息存放在对象的对象头中。

上面的工作完成后，对象已经产生了，所有字段都还为零，最后执行\<init>方法，把对象按照程序员的医院进行初始化，这样才得到一个真正可用的对象。

### 对象的内存布局

对象在内存中存储的布局可以分为：对象头、实例数据和对齐填充。

对象头包括两部分信息，一部分是用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。另一部分是类型指针，及对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果是数组，对象头中还有一块用于记录数组长度的数据。

### OutOfMemeoryError 异常实战

#### Java 堆溢出

除了程序计数器外，虚拟机中其他几个运行时区域都可能发生 OutOfMemeoryError 异常，下文简称 OOM

```bash
VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
```

上述代码限制 java 堆的大小为 20M（最小值-Xms 最大值-Xmx），通过参数`-XX:+HeapDumpOnOutOfMemoryError`可以让虚拟机在出现内存溢出异常时 Dumo 出当前内存对转储快照，以便事后进行分析。

#### 虚拟机栈和本地方法栈溢出

使用`-Xss`设定栈内存容量大小，例：`VM Args: -Xss2M`

递归过多或线程太多，大量的局部变量可能导致栈溢出。再不能减少线程数的情况下，只能通过减少最大堆和减少栈容量来换取更多的线程。

#### 方法区和运行时常量池溢出

运行时常量池是方法区的一部分，JDK1.7 开始，HotSpot 开始将方法区移出“永久代”。

在 JDK1.6 及之前的版本中，可以通过设置`-XX:PermSize`和`-XX:MaxPermSize`限制方法区的大小，从而间接的限制常量池的容量。例：`VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M`

方法区用于存放 Class 相关的信息，如雷鸣、访问修饰符、常量池、字段描述、方法描述等。测试方法是产生大量的类去填满方法区直到溢出，但是实验比较麻烦，可以使用 CGLib 直接操作字节码运行时产生大量的动态类。Spring、Hibernate 在对类增强时都会用到 CGLib 这类字节码技术。增强的类越多就需要越大的方法区来保证动态生成的 Class 可以加在到内存中。

#### 本机直接内存溢出

DirectMemory 容量可以通过`-XX:MaxDirectMemorySize`指定，如果不指定，则默认与 java 堆最大值（-Xmx 指定）一样，例：`VM Args -Xmx20M -XX:MaxDirectMemorySize=10M`

## 垃圾收集器和内存分配策略

### 引用计数法

给对象添加一个引用计数器，每当有地方引用它时，计数器的值就加 1，引用失效就减 1，计数器为 0 时不可能再被使用，即可回收。

引用计数法思想简单，判定效率高，Python 和游戏脚本 Squirrel 都是用它回收内存，但是主流的 java 虚拟机都没有选用引用计数法，主要原因是难以解决对象之间互相引用的问题

### 可达性分析算法

主流的商用语言 Java，C#，Lisp 都是使用可达性分析法来判断对象是否存活的。这个算法的思路是通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，如果一个对象不在引用链上，则证明此对象不可用。

java 语言中可作为 GC Roots 的对象包括下面几种：

1. 虚拟机栈（栈帧中的本地变量表）中的引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中 JNI（即一般说的额 Native 方法）引用的对象

### 再谈引用

JDK1.2 之前，java 中的引用的定义很传统：如果 reference 类型的数据中存储的数字代表的是另一块内存的其实地址，就称这块内存代表着一个引用。这种定义很纯粹戴氏过于狭隘。我们希望能描述这样的一类对象：当内存空间还足够时，则保留在内存中，如果内存空间中在垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都是符合这样的应用场景。

JDK1.2 之后，java 对应用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用 4 种，则 4 种引用强度一次减弱

1. 强引用：类似于`Object obj = new Object()`这类的引用，只要强引用存在对象就不会被回收
2. 软引用：描述一些有用但非必须的对象。在系统将要发生内存溢出异常之前，会把这些对象进行第二次回收，如果这次 GC 结束还是没有足够的内存，才会抛出内存溢出异常。可以使用 SoftReference 类来实现软引用
3. 弱引用：描述非必须对象，但强度比软引用更弱。无论内存是否足够，弱引用对象都会在下次 GC 进行回收（也就是逃过 1 次回收）。可以使用 WeakReference 类来实现弱引用
4. 虚引用：最弱的引用关系。虚引用不会对被引用对象产生任何影响，也无法通过弱引用获取到对象实例，它存在的唯一目的就是能在这个对象被回收时收到一个系统通知，可以使用 PhantomReference 类来实现虚引用

### 回收对象

对于不可达的对象，判断对象有没有覆盖 finalize()方法，如果对象没有覆盖或者 finalize()方法已经被虚拟机执行过，则直接回收；如果有待执行的 finalize()方法，则进入一个 F-Queue 队列之中，并在稍后有一个低优先级的 Finalizer 线程去执行它，如果在 finalize()方法中，对象又将自己关联了其他变量，则成功救活自己，不会被 GC，反之执行完遍直接回收

注意，任何对象的 finalize()方法都只会被执行一次，也就是只能救活自己一次，所以尽量避免使用这个方法，有些教材描述它用来关闭外部资源之类的工作，其实使用 try-finally 或其他方式可以做的更好

### 垃圾收集算法

1. 标记-清除算法

   首先标记出所有待回收的对象，回头统一回收，上面已经介绍了标记过程，该算法有两个不足之处：一是标记清除的过程效率不高，二是标记清除后产生了大量不连续内存碎片，碎片过多后续分配较大对象时会无法分配

2. 复制算法

   将一块内存按 1:1 的比例分为 AB 两部分，每次使用内存只使用其中一部分，例如只使用 A 而 B 完全不使用，进过几次 GC 后，A 碎片化严重，当 A 无法分配给新对象内存时，将 A 中的还存活的对象复制到 B 上，然后将 A 整个清理掉。这样就解决了内存碎片化问题，实现简单运行高效。但是算法的代价时缩小了一半的内存，代价太大了。

   根据 IBM 调查，98%的对象朝生夕死，所以 HotSpot 按 8:1 分配为 Eden 和 Survivor 两部分
