---
title: 并发分析
date: 2019-03-07 16:32:12
tags: java
---

一台电脑有很多程序在运行，也就有很多进程，一台单核的计算机给每个进程分配一定的时间（时间片）运行，然后快速切换到写一个进程，因为切换的很快，所以人感受不到程序的暂停，下面看一下时间片是怎么分配的：

>时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。  
>
>尽管初始时间片基本相等，但是后续被分配到的时间片长短并不是相等的，系统通过测量进程处于“睡眠”和“正在运行”状态的时间长短来计算每个进程的交互性，交互性和每个进程预设的静态优先级（Nice值）的叠加即是动态优先级，最后动态优先级按比例缩放就是要分配给那个进程时间片的长短。  
>
>--------维基百科

在操作系统中，有三个重要的概念：进程、线程、协程。

进程：当我们运行一个程序的时候，比如你的IDE或者QQ等，操作系统会为这个程序创建一个进程，这个进程包含了运行这个程序所需的各种资源，可以说它是一个容器，是属于这个程序的工作空间，比如它里面有内存空间、文件句柄、设备和线程等等。

线程：线程是一个执行的空间，比如要下载一个文件，访问一次网络等等。线程会被操作系统调用，来在不同的处理器上运行编写的代码任务，这个处理器不一定是该程序进程所在的处理。调度是操作系统负责的。线程是 **轻量级** 进程，他们是可以并行运行的，并且共享地使用他们所属进程共享一个地址空间，比如：内存空间或其他资源，不用特别麻烦的切换页表、刷新TLB，只要把寄存器刷新一遍就行，能比切换进程开销少点。

协程：自己在进程或线程里面写一个逻辑流调度的东西，这样就节省了上下文切换的消耗，这个就叫协程。举例来说：遇到I\O阻塞问题，可以多开一个线程去执行I/O操作，当阻塞的时候，cpu会切换线程，执行其他线程，等这次I/O完成后，切换回这个线程，执行后续逻辑。对于协程来说，只有一个线程，先发出I/O，阻塞后自己在线程里调度，切换到其他逻辑执行，待I/O结束后，切换并继续执行I/O的后续逻辑，节省了上下文切换的开销。

上下文切换的开销：线程是由CPU进行调度的，CPU的一个时间片内只执行一个线程上下文内的线程，当CPU由执行线程A切换到执行线程B的过程中会发生一些列的操作，这些操作主要有”保存线程A的执行现场“然后”载入线程B的执行现场”，这个过程称之为“上下文切换（context switch）”,这个上下文切换过程并不廉价，如果没有必要，应该尽量减少上下文切换的发生。

线程数量过多，上下文切换就会消耗相当多的时间，开销是巨大的。在面对高并发的情况下，单纯的创建线程反而不利于响应。工程中的最佳实践应该是`事件驱动 + 异步处理`。nginx、netty、nodejs都采用了这样的方案。

Nginx 的整体架构

- 主进程：负责执行特权操作，如阅读配置文件、绑定套接字、创建 / 通知协调（Signalling）子进程。
- 工作进程：负责接收和处理连接请求，读取和写入磁盘，并与上游服务器通信。当 NGINX 处于活跃状态时，只有工作进程是忙碌的。
- 缓存加载器进程：负责将磁盘高速缓存加载到内存中。这个进程在启动时运行后随即退出。
- 缓存管理器进程：负责整理磁盘缓存的数据保证其不越界。这个进程会间歇性运行。

Nginx 能够实现高性能和可扩展性的关键取决于两个基本的设计选型：

- 尽可能限制工作进程的数量，从而减少上下文切换带来的开销。默认和推荐配置是让每个 CPU 内核对应一个工作进程，从而高效利用硬件资源。
- 工作进程采用单线程，并以非阻塞的方式处理多个并发连接。

Nodejs的整体架构

- 主线程：解析和执行js
- 异步队列：使用libuv库实现，默认启用4个异步队列线程，可通过`process.env.UV_THREADPOOL_SIZE`调整线程数量

Nodejs高性能的原因在于自带的异步队列，每次执行完主线程的某个方法，就会切换到异步队列，进行event loop，执行那些已经完成的异步操作，并且nodejs采用了linux的[epoll](https://www.zhihu.com/question/20122137/answer/14049112)机制，不用遍历整个异步队列，而是直接可以获取到需要调用的回调函数，复杂度为O(1)。

而golang erlang akka 它们的并发使用了go routine ，轻进程，actor ，本质都极其轻量级的程序内部协程。这样就避免了线程的创建销毁和切换。本人也理解不深，不做过多介绍。